# CS789-Cryptography-Project
[functions_new.py](https://github.com/vikkijiang/CS789-Cryptography-Project/blob/main/functions_new.py): All the cryptographic functions taught in class to be used for this project <br />
[rsa_algamal.py](https://github.com/vikkijiang/CS789-Cryptography-Project/blob/main/rsa_elgamal.py): Simple UI implementing the RSA and Diffie-Hellman algorithm with with functions from functions_new.py <br />
[test.py](https://github.com/vikkijiang/CS789-Cryptography-Project/blob/main/test.py): Unit test file

## rsa_algamal.py User Guide
- The user will be prompted to choose between the RSA or Diffie_Hellman algorithm and their role
  - RSA:
    - Encrypt:
      - The user is expected to have already received the public key (e) and the modulus (n) from the person the want to send the message to. So the program will call the RSA_encrypt function to encrypt the users message with e and n for them to send over
    - Decrypt:
      - The user will be prompt if they have published their public key (e) and the modulus (n) for other people in the network to send them messages
        - If yes: The user can take the received encrypted message, their private key (d) and n to decrypt the message using the RSA_decrypt function
        - If no: The RSA_est will publish the public key (e) and the modulus (n) for the user to publish and also provide them the secret key (d) for when they decrypt
    - Intercept:
      - The user can intercept any message as long as they have the encrypted message, receiver's public key (e) and the modulus (n). The user will enter those values and the RSA_intercept function to obtain the plain text message
  - Diffie-Hellman:
    - Encrypt:
      - The user will be prompt if they have published a prime number (p) and its base (b)
        - If yes: the user can move on to encrypt a message assuming they have already received b_l from the person they want to send the message to. The program calls the dh_encrypt function with the values: prime number (p), its base (b), b_l and the plain text to encrypt the message. The message selected by the user should not be greater than the prime number.
        - If no: the user will be prompted to select a secret number (r) and the dh_est will generate a random prime number (p), a base, and b_r for the user to publish
    - Decrypt:
      - The user will be prompt if they have generated a b_l for exchanging messages
        - If yes: The user can move on to decrypt a message from the sender using the prime number (p), base (b) and the encrypted message by calling the dh_decrypt function
        - If no: The user would take the prime number (p), base (b) from the sender and select a secret number (l) to compute b_l for the sender to encrypt a message
    - Intercept:
      - The user can intercept any message as long as they have all the publicly published numbers prime number (p), base (b), b_r and b_l by calling the dh_decrypt function

## rsa_algamal.py Function Details
**RSA est**<br />
This function establishes a public key (e) and the modulus number (n) to be published for other users to use and send encrypted message to a user. The modulus number (n) is generated by which is generated by multiplying two prime numbers (p,q) using the blum_blum_shub algorithm indicating the number of bits the random number needs to be.
When generating the public key (e), the program will also provide the user their private key (d). d is the invers of e. To get that value, phi(n) is first calculated, that is (p-1)(q-1) and then perform expanded euclidean algorithm with phi(n) and e to obtain d.

**RSA_encrypt**<br />
The encrypted message is generated using the fast exponentiation function. Plain text message is raised to the power of the receiver's public key and take to modulus of n.

**RSA_decrypt**<br />
Similar to RSA_encrypt, a fast exponentiation function is used for a user to decrypt a ciphter text. The encrypted message is taken to the power of their private key (d) and then take the mod of n

**RSA_intercept**<br />
To obtain the plaintext from encrypted text without knowing the inverse of e (d), the user will have to determine the p and q using the Pollard's rho function that produced n. With that information, the user can determine phi(n) knowing p and q. Then the inverse of the receiver's public key (e) can be obtained taking the inverse of e using the expanded euclidean algorithm.

**dh_est**<br />
This function is for the user who wants to send another person a message. A random prime number (p) is generated using the Blum Blum Shub algorithm. Then the programs goes through a list of small prime numbers to determine the base (b) of the prime number using the primitive root search algorithm. Then the user will have to pick a number (r) as their secret. The base (b) will be raised to the power r mod p using fast exponentiation algorithm for the user to produce their public key b_r to publish.

**dh_est_d**<br />
The user is expected to have received a random prime number (p) and its base (b). They then will pick a secret number (l), b is raised to the power l mod p using fast exponentiation algorithm for the user to produce their public key b_l to publish.

**dh_encrypt**<br />
b_l is raised to the power of the sender's secret value (r) mod prime (p), which yields the shared secret. Then multiply the shared secret with the plain text message and mod p yields the encrypted text.

**dh_decrypt**<br />
b_r is raised to the power of the receiver's secret value (l) mod prime (p), which yields the shared secret. The receiver will have to then obtain the inverse of the shared secret. That can be done by performing fast exponentiation of shared secret raised to the power of (p-2) mod p, due to the property of Fermat's little theorem. Then multiply the shared secret inverse with the cipher text message and mod p yields the plain text.

**dh_intercept**<br />
The user can decrypt a cypher text maliciously as prime number (p), base (b), b_r and b_l are public information. The Baby-Giant algorithm to get the secret number r or l of either the sender or receiver. With either r or l, the user will know the shared secret of the two legitimate users. The inverse of the shared secret is obtained the same way as dh_decrypt using fast exponentiation. Then multiply the shared secret inverse with the cipher text message and mod p yields the plain text.
